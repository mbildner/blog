<title>Set.js - Sets in in JavaScript</title>

<h1 id="set-js-sets-in-in-javascript">Set.js - Sets in in JavaScript</h1>
<h1 id="-on-github-https-github-com-mbildner-set-js-"><a href="https://github.com/mbildner/Set.js">[on github]</a></h1>
<h2 id="sets-in-javascript">Sets in JavaScript</h2>
<p>JavaScript does not have a native implementation of sets. ES6 is <a href="http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets">expected</a>
expected to have sets built in, but for now JavaScript does not support sets out of the box.</p>
<h3 id="sets-polyfill">Sets polyfill</h3>
<p>Sets are conceptually extremely simple: they are unique collections that have to have the ability to add and remove elements while maintaining their internal uniqueness, and they must be able to be combined with other, similar sets.</p>
<p>Figuring out what a Set polyfill should look like turned out to be super easy. In retrospect, I should have just looked up the ES6 spec listed above and cloned that API (or as much of it as ES3/5 can support, ie no native iterating). Instead, I looked to <a href="http://redis.io/">Redis</a> for inspiration.</p>
<h3 id="redis-sets">Redis sets</h3>
<p>Redis is an amazing database system that I&#39;ve been playing around with lately. At its core, Redis supports the storage and manipulation of a few &quot;abstract data structures&quot;, including sets.</p>
<p>Redis has two types of sets, sorted and unsorted. Sorted sets are much cooler, but adding sorting seemed like unnecessary chrome for a quick curiosity-satisfying project, so I stuck with the more pedestrian unsorted set.</p>
<p>The API they expose (detailed <a href="http://redis.io/commands#set">here</a>) must include the following commands:</p>
<ol>
<li>Add</li>
<li>Intersect</li>
<li>Union</li>
<li>Length</li>
<li>Pop</li>
<li>Subtract</li>
<li>Test Membership</li>
<li>Get All Members</li>
<li>Get Random Member</li>
<li>Subtract Sets</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>I completely forgot to implement Subtraction. Everything else was relatively straightforward. The basic trick underlying the sets is to take an array and make it unique without doing a ton of work. This was accomplished by taking advantage of JavaScript&#39;s super simple hash maps, or as we call them in JavaScript, objects.</p>
<p>For the record, there are <a href="http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/">problems and dangers</a> presented by treating JS objects like they&#39;re just hash maps. But I&#39;m kind of a bad ass.</p>
<p>The uniquifying function at the core of the Set constructor is as follows:</p>
<pre><code class="lang-JavaScript">function makeUnique (arr) {
var obj = {};

arr.forEach(function (member) {
  obj[member] = true;
});

return Object.keys(obj);
}
</code></pre>
<p>Basically, by storing each property as a key in a hash we get JavaScript to do the hard work of figuring out which things are unique and throwing the extras away. Note that Array.prototype.forEach was used instead of Array.prototype.map. That was a <em>very</em> conscious design decision:</p>
<p><strong>map returns an array, forEach returns nothing</strong></p>
<p>As a general rule I prefer to use Array.prototype.map everywhere where you need to work with the transformation of an array. The only exception is when you want your operation to have some kind of side effect besides the creation of a new array. If the method call is going to change <em>ANYTHING AT ALL</em> use forEach to signal to other people that they cannot rely on things being the way they were before you ran your sneaky code.</p>
<p>In this case, the forEach call is supposed to change the intermediate storage object each time it fires its callback. We want people to know that. So we use forEach.</p>
<p>The rest of the implementation is equally simple. The basic trick is to take advantage internally of the fact that the set object can get its constituent members very easily, and so any operation that has to return a set can just grab that array and operate on it as necessary.</p>
<p>The project is reasonably well tested, <a href="https://github.com/mbildner/Set.js/blob/master/sets.spec.js">here</a>. The tests ensure that all methods work on at least a group of more than two members with at least two non-unique members, and that they work (or fail, if appropriate) on an empty set.</p>
<p>Writing a set implementation was actually a lot of fun. The two changes I would consider making are:</p>
<ul>
<li><p>Clone the EcmaScript Set API instead of using a (really awesome) foreign library.
Redis was chosen for inspiration because the project grew out of my thoughts about Redis, but I think that it would have been more productive for me to build something that mimics a real plan for this language. Not a big deal.</p>
<ul>
<li>Make returns the same type as inputs.
returns are all strings since in JavaScript, all object keys are strings (any non-string keys are coerced to their string representation implicitly when you initally set them). For what it&#39;s worth, Redis sets bear the same policy (return all strings), but as before, I think a JavaScript native project might have been better targeting JavaScript thinking.
Don&#39;t forget Set subtraction. That was stupid.</li>
</ul>
</li>
</ul>
<h3 id="do-it-yourself-it-s-really-fun">Do it yourself it&#39;s really fun</h3>
<p>I&#39;ll be picking other data structures in the future to clone. Even a really basic one like Set turned out to be a lot of fun. I&#39;d consider the implementation to be just about complete, except for the two problems listed above (set subtraction and non-string returns). But even with that complete, there&#39;s a ton of optimization work that would be a lot of fun to try out. But pick something that should be <em>really</em> basic and go ahead and make it yourself, it&#39;s rewarding and if you set the bar for success nice and low it&#39;s not that difficult.</p>
